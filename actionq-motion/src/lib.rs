#![allow(dead_code, unused_imports)]

mod common;
mod widget;
mod lua;

use std::{collections::HashMap, ops::Deref, path::Path};
use actionq_common::{Skeleton2D, SkeletonMap2D, SkeletonMap3D, CaptureData, skeleton_map_body_coco18};
use glam::{Vec2, Vec3};
use mlua::prelude::*;

pub use common::*;
pub use widget::*;

/// Exercise represented using a Lua script
#[derive(Debug)]
pub struct LuaExercise {
    /// Lua context
    ctx: Lua,
    /// Description of the exercise inside the database
    pub description: String,
    /// Name of the exercise inside the database
    pub name: String,
    /// Target number of repetitions to do
    pub repetitions_target: u32,
    /// Current number of repetitions done
    pub repetitions: u32,
    /// What are the required joints to observe for this script
    required_joints: Vec<String>,
    /// All invokable functions from the engine, 
    /// includes "setup", "load" and all functions defined in the STATES global variable 
    functions: HashMap<String, LuaFunction>,
    /// Current state name
    pub current_state: String,
    /// Accumulated warnings during the current repetition
    /// This get reseted at each repetition and is used for the repetition score
    accumulated_warnings: HashMap<String, u32>,
    /// Processed frames, with skeleton and state output
    pub frames: Vec<(SkeletonMap2D, StateOutput)>
}

/// Additional data generated by the state function
#[derive(Debug, Clone)]
pub struct Metadata {
    /// Emitted events, like the completion of a repetition
    pub events: Vec<StateEvent>,
    /// Warnings of the current frame
    pub warnings: Vec<StateWarning>,
    /// Message to display on the UI, 
    /// This is used to inform the patient on what to do next.
    /// Use this with the 'stay' state output function
    pub help: Option<String>,
    /// Widget to render on the ui on top of the video stream
    pub widgets: Vec<Widget>,
    /// Distance from the target objective to change state.
    /// This is usefull as an indication of how close the patient
    /// is to the correct control factor values.
    pub delta: Option<HashMap<String, f32>>
}

/// Output of a state function
#[derive(Debug, Clone)]
pub struct StateOutput {
    /// Next state name, if present
    pub next_state: Option<String>,
    /// Optional metadata
    pub metadata: Metadata
}

/// Supported events during the exercise
#[derive(Debug, Clone, PartialEq)]
pub enum StateEvent {
    /// The patient is in the correct initial position
    Start,
    /// The patient has completed a repetition
    Repetition
}

/// An error is represented by a name and some optional metadata
#[derive(Debug, Clone)]
pub struct StateWarning {
    pub name: String,
    pub metadata: Option<HashMap<String, f32>>,
}

/// Create a StateEvent from a Lua string
impl FromLua for StateEvent {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("parsing event!");
        if let LuaValue::String(s) = value {
            return Ok(
                match s.to_str()?.to_ascii_lowercase().as_str() {
                    "start" => StateEvent::Start,
                    "repetition" => StateEvent::Repetition,
                    _ => unimplemented!()
                }
            );
        }
        unimplemented!()
    }
}

/// Create a StateWarning from a Lua table
impl FromLua for StateWarning {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("parsing warning!");
        if let LuaValue::Table(t) = value {
            return Ok(
                Self {
                    metadata: t.get("metadata").ok(),
                    name: t.get("name")?,
                }
            )
        }
        unimplemented!()
    }
}

/// Create a state Metadata from a Lua table
impl FromLua for Metadata {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("parsing metadata!");
        match value {
            LuaValue::Nil => Ok(Self { warnings: vec![], events: vec![], widgets: vec![], help: None, delta: None }),
            LuaValue::Table(t) => Ok(
                Self { 
                    widgets: t.get("widgets").unwrap_or(vec![]),
                    warnings: t.get("warnings").unwrap_or(vec![]),
                    events: t.get("events").unwrap_or(vec![]),
                    delta: t.get("delta").ok(),
                    help: t.get("help").ok(),
                }
            ),
            _ => unimplemented!()
        }
    }
}

/// Create StateOutput from a Lua table
impl FromLua for StateOutput {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("parsing state output!");
        if let LuaValue::Table(t) = value {
            return Ok(
                Self {
                    next_state: t.get("next_state").ok(),
                    metadata: t.get("metadata")?
                }
            )
        }
        unimplemented!()
    }
}

impl LuaExercise {

    /// Insert all global data into lua context
    fn create_lua_ctx() -> LuaResult<Lua> {
        let ctx = Lua::new();

        lua::add_functions_control(&ctx)?;

        // Skeleton functions
        //lua::add_functions_vec2(&ctx)?;
        lua::add_functions_vec3(&ctx)?;

        // Near values by a margin
        ctx.globals().set("near",
            ctx.create_function(|_, (target, margin, value): (f32, f32, f32)| {
                let delta = (target - value).abs();
                Ok(delta < margin)
            })?
        )?;

        Ok(ctx)
    }

    /// Initialize exercise from Lua script as a file
    pub fn from_file(path: &Path, name: String, description: String, repetitions_target: u32) -> LuaResult<Self> {
        let fsm = std::fs::read_to_string(path)?;
        Self::from_string(fsm, name, description, repetitions_target)
    }

    /// Initialize esercise from Lua script as a string 
    pub fn from_string(script: String, name: String, description: String, repetitions_target: u32) -> LuaResult<Self> {
        
        let ctx = Self::create_lua_ctx()?;
        ctx.load(script).exec()?;
        let globals = ctx.globals();

        let mut functions = HashMap::<String, LuaFunction>::new();
        
        // Obtain all invokable functions in the STATES global variable
        let states: LuaTable = globals.get("STATES")?;
        states.for_each(|_: usize, v: String| {
            let func = globals.get::<LuaFunction>(v.clone())?;
            functions.insert(v, func);
            Ok(())
        })?;

        // Hardcoded functions
        functions.insert("setup".to_string(), globals.get::<LuaFunction>("setup")?);
        functions.insert("entry".to_string(), globals.get::<LuaFunction>("entry")?);
        dbg!(&functions);

        // Obtain required joints
        let required_joints = globals.get::<Vec<String>>("JOINTS")?;

        Ok(Self {
            ctx, 
            name,
            description,
            repetitions_target, 
            required_joints,
            current_state: "entry".to_string(),
            accumulated_warnings: HashMap::new(),
            frames: vec![],
            repetitions: 0, 
            functions,
        })
    }

    /// Convert a normal skeleton to a Lua table
    fn convert_skeleton(&self, skeleton: &SkeletonMap3D) -> LuaSkeletonMap3D {
        skeleton.iter()
            .map(|(k, v): (&String, &Vec3)| {
                (k.clone(), (*v).into())
            })
            .collect()
    }

    /// Change current state based on the current state output
    fn update_current_state(&mut self, output: &StateOutput) {
        if let Some(next_state) = &output.next_state {
            self.current_state = next_state.clone();
        }
    }

    /// Change number of repetitions done base on the current state output
    fn update_repetitions(&mut self, output: &StateOutput) {
        if output.metadata.events.iter().any(|v| *v == StateEvent::Repetition) {
            self.repetitions += 1;
        }
    }

    /// Accumulate warnings during the execution
    fn update_warnings(&mut self, output: &StateOutput) {
        for warning in &output.metadata.warnings {
            self.accumulated_warnings.entry(warning.name.clone())
                .and_modify(|acc| { *acc += 1 });
        }
    }

    /// Save current frame data and metadata for later storage
    fn store(&mut self, skeleton: &SkeletonMap2D, output: &StateOutput) {
        self.frames.push((skeleton.clone(), output.clone()));
    }

    /// Handle a skeleton from the HPE, returns true when the exercise is complete and state output if the exercise did run.
    pub fn process(&mut self, capture: &CaptureData) -> LuaResult<(bool, Option<StateOutput>)> {
        
        //println!("current state: {}", self.current_state);
        let state_fn = self.functions.get(&self.current_state)
            .expect("Invalid current state!");
    
        let pose_2d = skeleton_map_body_coco18(&capture.pose.keypoints_2d);
        let pose_3d = skeleton_map_body_coco18(&capture.pose.keypoints_3d);


        // If any required joint is missing from the frame skeleton, skip processing
        if self.required_joints.iter().any(|j| !pose_2d.contains_key(j)) {
            let missing: Vec<String> = self.required_joints.iter().cloned().filter(|j| !pose_2d.contains_key(j)).collect();
            let available: Vec<String> = pose_2d.keys().into_iter().cloned().collect();
            println!("missing: {:?}, available: {:?}", missing, available);
            return Ok((false, None));
        }

        // Evaluate current frame
        let lua_pose_3d = self.convert_skeleton(&pose_3d);
        let output: StateOutput = state_fn.call::<StateOutput>(lua_pose_3d)?;
        //dbg!(&output);

        self.store(&pose_2d, &output);
        self.update_current_state(&output);
        self.update_repetitions(&output);
        self.update_warnings(&output);

        let completed = self.repetitions >= self.repetitions_target;
        Ok((completed, Some(output)))
    }
}
