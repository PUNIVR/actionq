#![allow(dead_code, unused_imports)]

use std::{collections::HashMap, ops::Deref, path::Path};
use mlua::prelude::*;
use glam::Vec2;

/// Exercise represented using a Lua script
#[derive(Debug)]
pub struct LuaExercise {

    /// Lua context
    ctx: Lua,

    /// Description of the exercise inside the database
    pub description: String,
    /// Name of the exercise inside the database
    pub name: String,

    /// Target number of repetitions to do
    pub repetitions_target: u32,
    /// Current number of repetitions done
    pub repetitions: u32,

    /// What are the required joints to observe for this script
    required_joints: Vec<String>,

    /// All invokable functions from the engine, 
    /// includes "setup", "load" and all functions defined in the STATES global variable 
    functions: HashMap<String, LuaFunction>,
    /// Current state name
    pub current_state: String,

    /// Accumulated warnings during the current repetition
    /// This get reseted at each repetition and is used for the repetition score
    accumulated_warnings: HashMap<String, u32>,

    /// Processed frames, with skeleton and state output
    pub frames: Vec<(Skeleton, StateOutput)>
}

/// Custom widget to draw on screen over the video stream.
/// Used to help the patient reach the exercise goal.
#[derive(Debug, Clone)]
pub enum Widget {
    /// Small circle
    Circle {
        /// What text to show near or inside the circle
        text: Option<String>,
        /// At what offset from the position the text should be rendered
        text_offset: Vec2,
        /// At what position of the screen the circle should be rendered
        position: Vec2,
    },
    /// Vertical line
    VLine { x: f32 },
    /// Horizontal line
    HLine { y: f32 }
}

/// Additional data generated by the state function
#[derive(Debug, Clone)]
pub struct Metadata {

    /// Emitted events, like the completion of a repetition
    pub events: Vec<StateEvent>,

    /// Warnings of the current frame
    pub warnings: Vec<StateWarning>,

    /// Message to display on the UI, 
    /// This is used to inform the patient on what to do next.
    /// Use this with the 'stay' state output function
    pub help: Option<String>,

    /// Widget to render on the ui on top of the video stream
    pub widgets: Vec<Widget>,

    /// Distance from the target objective to change state.
    /// This is usefull as an indication of how close the patient
    /// is to the correct control factor values.
    pub delta: Option<HashMap<String, f32>>
}

/// Output of a state function
#[derive(Debug, Clone)]
pub struct StateOutput {

    /// Next state name, if present
    pub next_state: Option<String>,

    /// Optional metadata
    pub metadata: Metadata
}

/// Supported events during the exercise
#[derive(Debug, Clone, PartialEq)]
pub enum StateEvent {
    /// The patient is in the correct initial position
    Start,
    /// The patient has completed a repetition
    Repetition
}

/// An error is represented by a name and some optional metadata
#[derive(Debug, Clone)]
pub struct StateWarning {
    pub name: String,
    pub metadata: Option<HashMap<String, f32>>,
}

/// Create a Widget from a Lua table
impl FromLua for Widget {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::Table(t) = value {
            let widget_type: String = t.get("widget")?;
            return Ok(match widget_type.as_str() {
                "circle" => {

                    // From LuaVec2 to Vec2 with optionally None
                    let position: LuaVec2 = t.get("position")?;
                    
                    // BUG: this is Nil
                    //let text_offset: LuaVec2 = t.get("text_offset")
                    //    .unwrap_or(LuaVec2(Vec2::new(0.0, 0.0)));

                    let text_offset = Vec2::new(0.0, 0.0);

                    Widget::Circle {
                        position: position.0,
                        text_offset: text_offset,
                        text: t.get("text").ok(),
                    }
                },
                "hline" => Widget::HLine { y: t.get("y")? },
                "vline" => Widget::VLine { x: t.get("x")? },
                _ => unimplemented!()
            })
        }
        unimplemented!()
    }
}

/// Create a StateEvent from a Lua string
impl FromLua for StateEvent {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::String(s) = value {
            return Ok(
                match s.to_str()?.to_ascii_lowercase().as_str() {
                    "start" => StateEvent::Start,
                    "repetition" => StateEvent::Repetition,
                    _ => unimplemented!()
                }
            );
        }
        unimplemented!()
    }
}

/// Create a StateWarning from a Lua table
impl FromLua for StateWarning {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::Table(t) = value {
            return Ok(
                Self {
                    metadata: t.get("metadata").ok(),
                    name: t.get("name")?,
                }
            )
        }
        unimplemented!()
    }
}

/// Create a state Metadata from a Lua table
impl FromLua for Metadata {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        match value {
            LuaValue::Nil => Ok(Self { warnings: vec![], events: vec![], widgets: vec![], help: None, delta: None }),
            LuaValue::Table(t) => Ok(
                Self { 
                    widgets: t.get("widgets").unwrap_or(vec![]),
                    warnings: t.get("warnings").unwrap_or(vec![]),
                    events: t.get("events").unwrap_or(vec![]),
                    delta: t.get("delta").ok(),
                    help: t.get("help").ok(),
                }
            ),
            _ => unimplemented!()
        }
    }
}

/// Create StateOutput from a Lua table
impl FromLua for StateOutput {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::Table(t) = value {
            return Ok(
                Self {
                    next_state: t.get("next_state").ok(),
                    metadata: t.get("metadata")?
                }
            )
        }
        unimplemented!()
    }
}

/// Skeleton with the minimum amount of data required to work
pub type LuaSkeleton = HashMap<String, LuaVec2>;
pub type Skeleton = HashMap<String, Vec2>;

#[derive(Debug, Clone)]
pub struct LuaVec2(Vec2);

/// Convert a Vec2 into a LuaVec2. 
/// Necessary to implement traits on the Vec2 struct from glam.
impl Into<LuaVec2> for Vec2 {
    fn into(self) -> LuaVec2 {
        LuaVec2(self)
    }
}

/// Convert a LuaVec2 into a Vec2
impl Into<Vec2> for LuaVec2 {
    fn into(self) -> Vec2 {
        self.0
    }
}

/// Convert LuaVec2 to Lua table
impl IntoLua for LuaVec2 {
    fn into_lua(self, lua: &Lua) -> LuaResult<LuaValue> {
        let result = lua.create_table()?;
        result.set("x", self.0.x)?;
        result.set("y", self.0.y)?;
        Ok(LuaValue::Table(result))
    }
}

/// Convert Lua table into a LuaVec2
impl FromLua for LuaVec2 {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("{:?}", value);
        if let LuaValue::Table(t) = value {
            return Ok(LuaVec2(Vec2::new(
                t.get("x")?, t.get("y")?)))
        }
        unimplemented!()
    }
}

impl LuaExercise {

    /// Insert all global data into lua context
    fn create_lua_ctx() -> LuaResult<Lua> {
        let ctx = Lua::new();

        // Stay on same state, optionally supports state metadata
        ctx.globals().set("stay", 
            ctx.create_function(|lua, metadata: Option<LuaTable>| {
                let result = lua.create_table()?; // Create basic table
                result.set("next_state", LuaValue::Nil)?;
                result.set("metadata", metadata)?;
                Ok(result)
            })?
        )?;

        // Change state, first argument is the next state, optionally supports metadata
        ctx.globals().set("step", 
            ctx.create_function(|lua, (next_state, metadata): (String, Option<LuaTable>) | {
                let result = lua.create_table()?; // Create basic table
                result.set("next_state", next_state)?;
                result.set("metadata", metadata)?;
                Ok(result)
            })?
        )?;

        // TODO: Skeleton functions

        // Inner angle
        ctx.globals().set("inner_angle",
            ctx.create_function(|_, (a, z, b): (LuaVec2, LuaVec2, LuaVec2)| {

                let z2a = a.0 - z.0;
                let z2b = b.0 - z.0;

                let k = z2a.dot(z2b)/(z2a.length()*z2b.length());
                let r = k.acos().to_degrees();

                Ok(r)
            })?
        )?;

        // Inner angle aligned
        ctx.globals().set("inner_angle_aligned",
            ctx.create_function(|_, (a, z, b): (LuaVec2, LuaVec2, LuaVec2)| {
                
                let a2z = z.0 - a.0;
                let z2b = b.0 - z.0;

                let k = a2z.dot(z2b)/(a2z.length()*z2b.length());
                let r = k.acos().to_degrees();

                Ok(r)
            })?
        )?;

        // Angle compared to a reference axix
        ctx.globals().set("inner_angle_aligned_axis",
            ctx.create_function(|_, (axis, a, b): (LuaVec2, LuaVec2, LuaVec2)| {
                let axis = axis.0;
                let d = b.0 - a.0;
                let k = axis.dot(d)/(axis.length()*d.length());
                Ok(k.acos().to_degrees())
            })?
        )?;

        // Near values by a margin
        ctx.globals().set("near",
            ctx.create_function(|_, (target, margin, value): (f32, f32, f32)| {
                let delta = (target - value).abs();
                Ok(delta < margin)
            })?
        )?;

        Ok(ctx)
    }

    /// Initialize exercise from Lua script as a file
    pub fn from_file(path: &Path, name: String, description: String, repetitions_target: u32) -> LuaResult<Self> {
        let fsm = std::fs::read_to_string(path)?;
        Self::from_string(fsm, name, description, repetitions_target)
    }

    /// Initialize esercise from Lua script as a string 
    pub fn from_string(script: String, name: String, description: String, repetitions_target: u32) -> LuaResult<Self> {
        
        let ctx = Self::create_lua_ctx()?;
        ctx.load(script).exec()?;
        let globals = ctx.globals();

        let mut functions = HashMap::<String, LuaFunction>::new();
        
        // Obtain all invokable functions in the STATES global variable
        let states: LuaTable = globals.get("STATES")?;
        states.for_each(|_: usize, v: String| {
            let func = globals.get::<LuaFunction>(v.clone())?;
            functions.insert(v, func);
            Ok(())
        })?;

        // Hardcoded functions
        functions.insert("setup".to_string(), globals.get::<LuaFunction>("setup")?);
        functions.insert("entry".to_string(), globals.get::<LuaFunction>("entry")?);

        // Obtain required joints
        let required_joints = globals.get::<Vec<String>>("JOINTS")?;

        Ok(Self {
            ctx, 
            name,
            description,
            repetitions_target, 
            required_joints,
            current_state: "entry".to_string(),
            accumulated_warnings: HashMap::new(),
            frames: vec![],
            repetitions: 0, 
            functions,
        })
    }

    /// Convert a normal skeleton to a Lua table
    fn convert_skeleton(&self, skeleton: &Skeleton) -> LuaSkeleton {
        skeleton.iter()
            .map(|(k, v): (&String, &Vec2)| {
                (k.clone(), (*v).into())
            })
            .collect()
    }

    /// Change current state based on the current state output
    fn update_current_state(&mut self, output: &StateOutput) {
        if let Some(next_state) = &output.next_state {
            self.current_state = next_state.clone();
        }
    }

    /// Change number of repetitions done base on the current state output
    fn update_repetitions(&mut self, output: &StateOutput) {
        if output.metadata.events.iter().any(|v| *v == StateEvent::Repetition) {
            self.repetitions += 1;
        }
    }

    /// Accumulate warnings during the execution
    fn update_warnings(&mut self, output: &StateOutput) {
        for warning in &output.metadata.warnings {
            self.accumulated_warnings.entry(warning.name.clone())
                .and_modify(|acc| { *acc += 1 });
        }
    }

    /// Save current frame data and metadata for later storage
    fn store(&mut self, skeleton: &Skeleton, output: &StateOutput) {
        self.frames.push((skeleton.clone(), output.clone()));
    }

    /// Handle a skeleton from the HPE, returns true when the exercise is complete and state output if the exercise did run.
    pub fn process(&mut self, skeleton: &Skeleton) -> LuaResult<(bool, Option<StateOutput>)> {
        let state_fn = self.functions.get(&self.current_state)
            .expect("Invalid current state!");
    
        // If any required joint is missing from the frame skeleton, skip processing
        if self.required_joints.iter().any(|j| !skeleton.contains_key(j)) {
            let missing: Vec<String> = self.required_joints.iter().cloned().filter(|j| !skeleton.contains_key(j)).collect();
            let available: Vec<String> = skeleton.keys().into_iter().cloned().collect();
            println!("missing: {:?}, available: {:?}", missing, available);
            return Ok((false, None));
        }

        // Evaluate current frame
        let lua_skeleton = self.convert_skeleton(skeleton);
        let output = state_fn.call::<StateOutput>(lua_skeleton)?;
        self.store(skeleton, &output);

        self.update_current_state(&output);
        self.update_repetitions(&output);
        self.update_warnings(&output);

        let completed = self.repetitions >= self.repetitions_target;
        Ok((completed, Some(output)))
    }

}
