#![allow(dead_code, unused_imports)]

mod lua;
mod widget;

use actionq_common::{
    skeleton_map_body_coco18, CaptureData, Skeleton2D, SkeletonMap2D, SkeletonMap3D,
};
use glam::{Vec2, Vec3};
use mlua::prelude::*;
use serde::{Deserialize, Serialize};
use std::{collections::{HashMap, HashSet}, ops::Deref, path::Path};

pub use widget::*;

/// Describes a exercise parameter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParameterDescriptor {
    name: String,
    description: String,
    default: f32
}

/// A Parameter is unique depending on its name
impl std::hash::Hash for ParameterDescriptor {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.name.hash(state);
    }
}

impl Eq for ParameterDescriptor {}
impl PartialEq for ParameterDescriptor {
    fn eq (self: & Self, other: &Self) -> bool {
        self.name.eq(&other.name)
    }
}

/// Exercise represented using a Lua script
#[derive(Debug)]
pub struct LuaExercise {
    /// Lua context
    ctx: Lua,
    /// Description of the exercise inside the database
    pub description: String,
    /// Name of the exercise inside the database
    pub name: String,
    /// Default parameters of the exercise from script
    pub default_parameters: HashSet<ParameterDescriptor>,
    /// Actual runtime parameters of the exercise
    pub parameters: HashMap<String, f32>,
    /// Target number of repetitions to do
    pub repetitions_target: u32,
    /// Current number of repetitions done
    pub repetitions: u32,
    /// What are the required joints to observe for this script
    required_joints: Vec<String>,
    /// All invokable functions from the engine,
    /// includes "setup", "load" and all functions defined in the STATES global variable
    functions: HashMap<String, LuaFunction>,
    /// Scratch buffer for widgets drawing
    widgets: LuaTable,
    /// Current state name
    pub current_state: String,
    /// This get reseted at each repetition and is used for the repetition score
    accumulated_warnings: HashMap<String, u32>,
    /// Processed frames, with skeleton and state output
    pub frames: Vec<(SkeletonMap2D, StateOutput)>,
}

/// Additional data generated by the state function
#[derive(Debug, Clone)]
pub struct Metadata {
    /// Emitted events, like the completion of a repetition
    pub events: Vec<StateEvent>,
    /// Warnings of the current frame
    pub warnings: Vec<StateWarning>,
    /// Message to display on the UI,
    /// This is used to inform the patient on what to do next.
    /// Use this with the 'stay' state output function
    pub help: Option<String>,
    /// Widget to render on the ui on top of the video stream
    pub widgets: Vec<Widget>,
}

/// Output of a state function
#[derive(Debug, Clone)]
pub struct StateOutput {
    /// Next state name, if present
    pub next_state: Option<String>,
    /// Optional metadata
    pub metadata: Metadata,
}

/// Supported events during the exercise
#[derive(Debug, Clone, PartialEq)]
pub enum StateEvent {
    /// The patient is in the correct initial position
    Start,
    /// The patient has completed a repetition
    Repetition,
}

/// An error is represented by a name and some optional metadata
#[derive(Debug, Clone)]
pub struct StateWarning {
    pub name: String,
    pub metadata: Option<HashMap<String, f32>>,
}

/// Create a StateEvent from a Lua string
impl FromLua for StateEvent {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        //println!("parsing event!");
        if let LuaValue::String(s) = value {
            return Ok(match s.to_str()?.to_ascii_lowercase().as_str() {
                "start" => StateEvent::Start,
                "repetition" => StateEvent::Repetition,
                _ => unimplemented!(),
            });
        }
        unimplemented!()
    }
}

/// Create a StateWarning from a Lua table
impl FromLua for StateWarning {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::Table(t) = value {
            return Ok(Self {
                metadata: t.get("metadata").ok(),
                name: t.get("name")?,
            });
        }
        unimplemented!()
    }
}

/// Create a state Metadata from a Lua table
impl FromLua for Metadata {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        match value {
            LuaValue::Nil => Ok(Self {
                warnings: vec![],
                events: vec![],
                widgets: vec![],
                help: None,
            }),
            LuaValue::Table(t) => Ok(Self {
                widgets: t.get("widgets").unwrap_or(vec![]),
                warnings: t.get("warnings").unwrap_or(vec![]),
                events: t.get("events").unwrap_or(vec![]),
                help: t.get("help").ok(),
            }),
            _ => unimplemented!(),
        }
    }
}

/// Create StateOutput from a Lua table
impl FromLua for StateOutput {
    fn from_lua(value: LuaValue, _: &Lua) -> LuaResult<Self> {
        if let LuaValue::Table(t) = value {
            return Ok(Self {
                next_state: t.get("next_state").ok(),
                metadata: t.get("metadata")?,
            });
        }
        unimplemented!()
    }
}

impl LuaExercise {
    /// Insert all global data into lua context
    fn create_lua_ctx() -> LuaResult<Lua> {
        let ctx = Lua::new();

        let aq = ctx.create_table()?;
        aq.set("state", lua::control_module(&ctx)?)?;
        aq.set("draw",  lua::draw_module(&ctx)?)?;
        aq.set("math",  lua::math_module(&ctx)?)?;
        ctx.globals().set("aq", aq)?;

        // Near values by a margin
        ctx.globals().set(
            "near",
            ctx.create_function(|_, (target, margin, value): (f32, f32, f32)| {
                let delta = (target - value).abs();
                Ok(delta < margin)
            })?,
        )?;

        Ok(ctx)
    }

    /// Initialize exercise from Lua script as a file
    pub fn from_file(
        path: &Path,
        name: String,
        description: String,
        repetitions_target: u32,
        build_parameters: &[(String, f32)],
    ) -> LuaResult<Self> {
        let fsm = std::fs::read_to_string(path)?;
        Self::from_string(fsm, name, description, repetitions_target, build_parameters)
    }

    /// Initialize esercise from Lua script as a string
    pub fn from_string(
        script: String,
        name: String,
        description: String,
        repetitions_target: u32,
        build_parameters: &[(String, f32)],
    ) -> LuaResult<Self> {
        let ctx = Self::create_lua_ctx()?;
        ctx.load(script).exec()?;
        let globals = ctx.globals();

        let mut functions = HashMap::<String, LuaFunction>::new();

        // Obtain all invokable functions in the STATES global variable
        let states: LuaTable = globals.get("STATES")?;
        states.for_each(|_: usize, v: String| {
            let func = globals.get::<LuaFunction>(v.clone())?;
            functions.insert(v, func);
            Ok(())
        })?;

        // Add scratch buffer for widgets drawing
        globals.set("_widgets_buffer", ctx.create_table()?)?;
        let widgets: LuaTable = globals.get("_widgets_buffer")?;

        // Hardcoded functions
        functions.insert("setup".to_string(), globals.get::<LuaFunction>("setup")?);
        functions.insert("entry".to_string(), globals.get::<LuaFunction>("entry")?);

        // Obtain required joints
        let required_joints = globals.get::<Vec<String>>("JOINTS")?;

        // Obtain default configuration
        let default_parameters: HashSet<ParameterDescriptor> = globals.get::<LuaTable>("PARAMETERS")?
            .sequence_values()
            .map(|v| ctx.from_value::<ParameterDescriptor>(v.unwrap())
                .expect("Invalid parameter definition!"))
            .collect();

        // The runtime configuration is the default one updated with build configuration
        let mut parameters: HashMap<String, f32> = default_parameters.iter()
            .map(|p| (p.name.clone(), p.default))
            .collect();

        parameters.extend(build_parameters.iter().cloned());

        Ok(Self {
            ctx,
            name,
            description,
            default_parameters,
            parameters,
            repetitions_target,
            required_joints,
            current_state: "entry".to_string(),
            accumulated_warnings: HashMap::new(),
            frames: vec![],
            repetitions: 0,
            functions,
            widgets
        })
    }

    /// Change current state based on the current state output
    fn update_current_state(&mut self, output: &StateOutput) {
        if let Some(next_state) = &output.next_state {
            self.current_state = next_state.clone();
        }
    }

    /// Change number of repetitions done base on the current state output
    fn update_repetitions(&mut self, output: &StateOutput) {
        if output
            .metadata
            .events
            .iter()
            .any(|v| *v == StateEvent::Repetition)
        {
            self.repetitions += 1;
        }
    }

    /// Accumulate warnings during the execution
    fn update_warnings(&mut self, output: &StateOutput) {
        for warning in &output.metadata.warnings {
            self.accumulated_warnings
                .entry(warning.name.clone())
                .and_modify(|acc| *acc += 1);
        }
    }

    /// Save current frame data and metadata for later storage
    fn store(&mut self, skeleton: &SkeletonMap2D, output: &StateOutput) {
        self.frames.push((skeleton.clone(), output.clone()));
    }

    /// Handle a skeleton from the HPE, returns true when the exercise is complete and state output if the exercise did run.
    pub fn process(&mut self, capture: &CaptureData) -> LuaResult<(bool, Option<StateOutput>)> {
        let state_fn = self
            .functions
            .get(&self.current_state)
            .expect("Invalid current state!");

        // Reset widgets scratch buffer
        self.widgets.clear()?;

        // If any required joint is missing from the frame skeleton, skip processing
        if self
            .required_joints
            .iter()
            .any(|j| !capture.pose.kp2d.contains_key(j))
        {
            let missing: Vec<String> = self
                .required_joints
                .iter()
                .cloned()
                .filter(|j| !capture.pose.kp2d.contains_key(j))
                .collect();

            let available: Vec<String> = capture.pose.kp2d.keys().into_iter().cloned().collect();
            println!("missing: {:?}, available: {:?}", missing, available);
            return Ok((false, None));
        }

        // Evaluate current frame
        let mut output: StateOutput = state_fn.call((
            self.ctx.to_value(&capture.pose)?, 
            self.ctx.to_value(&self.parameters)?
        ))?;

        // Insert widgets from the immediate mode into the output
        for widget in self.widgets.sequence_values() {
            let widget: Widget = self.ctx.from_value(widget?)?;
            output.metadata.widgets.push(widget);
        }

        self.store(&capture.pose.kp2d, &output);
        self.update_current_state(&output);
        self.update_repetitions(&output);
        self.update_warnings(&output);

        let completed = self.repetitions >= self.repetitions_target;
        Ok((completed, Some(output)))
    }
}
